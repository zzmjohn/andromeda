(* Universes with constraints. *)

(* Given f and θ : a ≡ b, construct a witness of f a ≡ f b. *)
let f_apply f θ =
  match (f, θ) with
  | ((⊢ ?f : ∏ (?x : ?A), ?B), (⊢ ?θ : ?a ≡ ?b)) =>
    congr_apply x (refl f) θ (refl A) (refl B)
  end

(* The type of all universe indices and its partial orders *)
constant Index : Type
constant ( < ) : Index → Index → Type
constant ( <= ) : Index → Index → Type

(* The partial orders are proof-irrelevant *)
constant lt_uip : ∏ (i j : Index) (p q : i < j), p ≡ q
now etas = add_eta lt_uip

constant leq_uip : ∏ (i j : Index) (p q : i <= j), p ≡ q
now etas = add_eta leq_uip

(* The strict order is contained in the non-strict one *)
constant lt_leq : ∏ (i j : Index), i < j → i <= j

(* The non-strict order is reflexive *)
constant leq_refl : ∏ i : Index, i <= i

(* A family of universes. *)
constant U : Index → Type

(* If p : i < j then U i has a name u i j p in U j *)
constant u : Π (i j : Index), i < j → U j

(* The elements of a universe are names of types *)
constant El : Π (i : Index), U i → Type

constant u_El : Π (i j : Index) (p : i < j), El j (u i j p) ≡ U i
now betas = add_beta u_El

constant lift : ∏ (i j : Index) (p : i <= j), U i → U j
constant lift_El :
   ∏ (i j : Index) (p : i <= j) (a : U i), El j (lift i j p a) ≡ El i a

(* The following might be used to make people's brains happy(er) *)
(* constant lift_id : ∏ (i : Index) (p : i <= i) (a : U i), lift i i p a ≡ a
   now betas = add_beta lift_id *)

(* Names of dependent products *)
constant pi : Π (i : Index), ∏ (a : U i), (El i a → U i) → U i
constant pi_El :
   Π (i : Index) (a : U i) (b : El i a → U i),
     El i (pi i a b) ≡ (Π (x : El i a), El i (b x))
now betas = add_beta pi_El

(* The name of an equality type *)
constant eq : Π (i : Index) (a : U i), El i a → El i a → U i
constant eq_El : ∏ (i : Index) (a : U i) (x y : El i a), El i (eq i a x y) ≡ (x ≡ y)
now betas = add_beta eq_El

(* To have something to work with we give ourselves a base type *)
constant Cow : Type

constant cow : Π (i : Index), U i
constant cow_El: Π (i : Index), El i (cow i) ≡ Cow
now betas = add_beta cow_El

(* Just for fun we assume that the Index type has a name in every universe *)
constant index : Π (i : Index), U i
constant index_El: Π (i : Index), El i (index i) ≡ Index
now betas = add_beta index_El

(* We do not want the user to worry about the indices so we do magic with handlers. *)

operation UU : judgment

(* Produce the assumption that i <= j *)
let prove_leq i j =
  assume p : i <= j in p

(* Produce the assumption that i < j *)
let prove_lt i j =
  assume p : i < j in p

(* Reverse engineer the name of a type T in universe U j
   with a proof that it is correctly reverse engineered *)
let rec name_of T j =
  match T with
  | ⊢ Cow => Some (cow_El j)

  | ⊢ U ?i =>
      let p = prove_lt i j in
      Some (u_El i j p)

  | ⊢ Index => Some (index_El j)

  | ⊢ El j _ => Some (refl T)

  | ⊢ El ?i ?a =>
      let p = prove_leq i j in
      Some (lift_El i j p a)

  | ⊢ (?x ≡ ?y) =>
      let A = typeof x in
      match name_of A j with
      | None => None
      | Some (⊢ ?ξ : El j ?a ≡ _) => 
        let x' = convert x (symmetry ξ)
        and y' = convert y (symmetry ξ) in
        let α = (eq_El j a x' y') in
        let β = convert_eq (x' ≡ y') ξ  in
        Some (transitivity α β)
      end

  | ⊢ Π (?x : ?A), ?B =>
      match name_of A j with
      | None => None
      | Some (⊢ ?ξ : El j ?a ≡ _) => 
          match name_of B j with
          | None => None
          | Some (⊢ ?ξ2 : El j ?b ≡ _) => 
             Some (pi_El j a (λ (y : El j a), b where x = y))
          end
      end

  | ?J => 
    match whnf T with
    | ⊢ ?ζ : _ ≡ ?T' =>
      match T' with
      | T => None
      | _ => 
        match name_of T' j with
        | Some (⊢ ?ξ : El j ?a ≡ _) =>
            let answer = tran Type (El j a) T' T ξ (symmetry ζ)  in
            Some answer
        | None => None
        end
      end
    end
  end

let universe_handler =
  handler

  | coerce (⊢ ?a : ?B) (⊢ Type) =>
    match whnf B with
    | ⊢ ?ξ : _ ≡ U ?i => 
      match whnf (El i a) with ⊢ _ : _ ≡ ?A => yield (Coercible A) end
    | _ => yield (coerce a Type)
    end

  | coerce (⊢ ?a : ?B) (⊢ U ?j) =>
    match whnf B with
    | ⊢ _ : _ ≡ Type =>
      match name_of a j with
      | None => yield NotCoercible
      | Some (⊢ _ : El _ ?a ≡ _) => yield (Coercible a)
      end
    | ⊢ _ : _ ≡ U ?i =>
      let p = prove_leq i j in
      yield (Coercible (lift i j p a))
    end

  | UU : None => 
    assume i : Index in
    assume j : Index in
    assume p : i < j in
      yield (u i j p)

  | UU : Some ?A =>
    match whnf A with
    | ⊢ ?ξ : _ ≡ U ?j =>
        assume i : Index in
        assume p : i < j in
          yield (convert (u i j p) (symmetry ξ))
    | ⊢ ?ξ : _ ≡ Type =>
      assume i : Index in
        yield (convert (U i) (symmetry ξ))
    end

  | equal (⊢ U ?i) (⊢ U ?j) =>
    assume θ : i ≡ j in
    yield (Some (f_apply U θ))
  end

(* Examples *)

do
  with universe_handler handle
    Cow : UU

do
  with universe_handler handle
    UU : UU

do
  with universe_handler handle
   ((UU : UU) : UU)

do with universe_handler handle
  assume x : Cow in
     (x ≡ x) : UU

(* For this to work we need to put in whnf coercions around line 152 *)
fail with universe_handler handle
  ((λ (A : UU) (x : A), x) UU) : UU

(* This should fail, and it does because it does not find a uniform bound for U i. *)
fail
   with universe_handler handle (Π (i : Index), U i) : UU

(* This example almost work. The universe mechanism genereates the relevant equality
   between indices, but then it does not get used. *)
fail with universe_handler handle
   (λ (A : UU) (a : A), a) : ∏ (B : UU), B → B
